12/22/2025 10:40am Removed hidden columns for rework and fixed auto updates on Gloves tab.



/**
 * Glove Manager â€“ Rubber Glove & Sleeve Inventory System
 *
 * Google Apps Script foundation for automating and managing PPE inventory, assignments, swaps, compliance, and reporting.
 *
 * Hidden columns functionality (Kâ€“W) for Glove Swaps tab has been removed as of Dec 2025. All workflow and state is now managed only in visible columns (Aâ€“J).
 *
 * Expand each placeholder as features are implemented. Logging and error handling included for maintainability.
 */

// Sheet/tab name constants
const SHEET_EMPLOYEES = 'Employees';
const SHEET_GLOVES = 'Gloves';
const SHEET_SLEEVES = 'Sleeves';
const SHEET_GLOVE_SWAPS = 'Glove Swaps';
const SHEET_SLEEVE_SWAPS = 'Sleeve Swaps';
const SHEET_PURCHASE_NEEDS = 'Purchase Needs';
const SHEET_INVENTORY_REPORTS = 'Inventory Reports';
const SHEET_RECLAIMS = 'Reclaims';
const SHEET_HISTORY = 'History';

// Header background color for swap tables
const HEADER_BG_COLOR = '#1565c0';

/**
 * Creates an installable onEdit trigger. Run this once from the Apps Script editor.
 * Go to Run > createEditTrigger
 *
 * IMPORTANT: Before running, manually delete ALL existing triggers in the Triggers page!
 */
function createEditTrigger() {
  // Remove ALL existing edit triggers to avoid duplicates
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    var handlerName = triggers[i].getHandlerFunction();
    // Delete any onEdit or onEditHandler triggers
    if (handlerName === 'onEditHandler' || handlerName === 'onEdit') {
      ScriptApp.deleteTrigger(triggers[i]);
      Logger.log('Deleted trigger: ' + handlerName);
    }
  }
  // Create single new installable trigger
  ScriptApp.newTrigger('onEditHandler')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();
  Logger.log('Edit trigger installed successfully! Only one onEditHandler trigger should now exist.');
}

/**
 * Installable onEdit handler - called by the trigger
 */
function onEditHandler(e) {
  processEdit(e);
}

/**
 * Writes dynamic swap table headers for Glove/Sleeve Swaps sheets.
 * Supports any number of swap workflow stages.
 * @param {Sheet} swapSheet - The sheet to write headers to.
 * @param {number} currentRow - The row to start writing headers (1-based).
 * @param {string} itemType - 'Gloves' or 'Sleeves'.
 * @param {string} headerFont - Font color for visible headers.
 * @param {number} numStages - Number of swap workflow stages.
 * @return {number} The next available row after headers.
 */
function writeSwapTableHeadersDynamic(swapSheet, currentRow, itemType, headerFont, numStages) {
  const itemNumHeader = itemType === 'Gloves' ? 'Current Glove #' : 'Current Sleeve #';
  // Only visible headers (Aâ€“J)
  const visibleHeaders = [
    'Employee',           // A
    itemNumHeader,        // B
    'Size',               // C
    'Date Assigned',      // D
    'Change Out Date',    // E
    'Days Left',          // F
    'Pick List',          // G
    'Status',             // H
    'Picked',             // I
    'Date Changed'        // J
  ];
  swapSheet.getRange(currentRow, 1, 1, visibleHeaders.length).setValues([visibleHeaders]);
  swapSheet.getRange(currentRow, 1, 1, visibleHeaders.length)
    .setFontWeight('bold').setFontColor(headerFont).setHorizontalAlignment('center').setBackground(HEADER_BG_COLOR);
  return currentRow + 1;
}

/**
 * Adds a custom menu to the Google Sheet for Glove Manager actions.
 */
function onOpen() {
  ensurePickedForColumn();
  SpreadsheetApp.getUi()
    .createMenu('Glove Manager')
    .addItem('Build Sheets', 'buildSheets')
    .addItem('Generate All Reports', 'generateAllReports')
    .addSeparator()
    .addItem('Generate Glove Swaps', 'generateGloveSwaps')
    .addItem('Generate Sleeve Swaps', 'generateSleeveSwaps')
    .addItem('Update Purchase Needs', 'updatePurchaseNeeds')
    .addItem('Update Inventory Reports', 'updateInventoryReports')
    .addItem('Run Reclaims Check', 'runReclaimsCheck')
    .addItem('View History', 'viewHistory')
    .addToUi();
}

/**
 * Logging utility for consistent logs and error tracking.
 */
function logEvent(message, level = 'INFO') {
  const now = new Date();
  Logger.log(`[${level}] [${now.toISOString()}] ${message}`);
}

/**
 * Idempotently creates all required sheets/tabs and headers for the Glove Manager system.
 */
function buildSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetDefs = [
    { name: SHEET_EMPLOYEES, headers: ['Name', 'Class', 'Location', 'Job Number', 'Phone Number', 'Notification Emails', 'MP Email', 'Email Address', 'Glove Size', 'Sleeve Size'] },
    { name: SHEET_GLOVES, headers: ['Glove', 'Size', 'Class', 'Test Date', 'Date Assigned', 'Location', 'Status', 'Assigned To', 'Change Out Date', 'Notes'] },
    { name: SHEET_SLEEVES, headers: ['Sleeve', 'Size', 'Class', 'Test Date', 'Date Assigned', 'Location', 'Status', 'Assigned To', 'Change Out Date', 'Notes'] },
    { name: SHEET_GLOVE_SWAPS, headers: ['Employee', 'Item Number', 'Size', 'Date Assigned', 'Change Out Date', 'Days Left', 'Pick List', 'Status', 'Checkbox', 'Date Changed'] },
    { name: SHEET_SLEEVE_SWAPS, headers: ['Employee', 'Item Number', 'Size', 'Date Assigned', 'Change Out Date', 'Days Left', 'Pick List', 'Status', 'Checkbox', 'Date Changed'] },
    { name: SHEET_PURCHASE_NEEDS, headers: ['Item Type', 'Size', 'Class', 'Quantity Needed', 'Reason', 'Status/Notes'] },
    { name: SHEET_INVENTORY_REPORTS, headers: ['Report Type', 'Class', 'Location', 'Count', 'Notes'] },
    { name: SHEET_RECLAIMS, headers: ['Location', 'Approval Status', 'Employee', 'Item Number', 'Class', 'Action Needed'] },
    { name: SHEET_HISTORY, headers: ['Timestamp', 'Action', 'Item Type', 'Item Number', 'Employee', 'Old Value', 'New Value', 'User', 'Source/Notes'] }
  ];
  sheetDefs.forEach(def => {
    let sheet = ss.getSheetByName(def.name);
    if (!sheet) {
      sheet = ss.insertSheet(def.name);
      sheet.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
    } else if ([SHEET_EMPLOYEES, SHEET_GLOVES, SHEET_SLEEVES].includes(def.name)) {
      // Only set headers if sheet is empty (no data)
      if (sheet.getLastRow() === 0) {
        sheet.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
      }
      // Do not clear or overwrite any data
    } else {
      sheet.clear();
      sheet.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
    }
    // Formatting for Employees, Gloves, Sleeves
    if ([SHEET_EMPLOYEES, SHEET_GLOVES, SHEET_SLEEVES].includes(def.name)) {
      sheet.setFrozenRows(1);
      sheet.setFrozenColumns(1);
      var headerRange = sheet.getRange(1, 1, 1, def.headers.length);
      headerRange.setBackground('#1565c0'); // Blue
      headerRange.setFontColor('#ffffff'); // White
      headerRange.setFontWeight('bold');
      var lastRow = sheet.getLastRow();
      var lastCol = def.headers.length;
      if (lastRow > 1) {
        sheet.getRange(2, 1, lastRow - 1, lastCol).setHorizontalAlignment('center');
      }
      // Center header row too
      headerRange.setHorizontalAlignment('center');
    }
    // Formatting for Glove Swaps, Sleeve Swaps
    if ([SHEET_GLOVE_SWAPS, SHEET_SLEEVE_SWAPS].includes(def.name)) {
      var swapSheet = sheet;
      var swapHeaders = def.headers.length;
      swapSheet.getRange(1, 1, 1, swapHeaders).setHorizontalAlignment('center');
      var swapLastRow = swapSheet.getLastRow();
      if (swapLastRow > 1) {
        swapSheet.getRange(2, 1, swapLastRow - 1, swapHeaders).setHorizontalAlignment('center');
      }
    }
  });
  logEvent('Sheets built or reset.');
}

/**
 * Utility to insert the 'Picked For' column if not present in Gloves and Sleeves tabs.
 */
function ensurePickedForColumn() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_GLOVES, SHEET_SLEEVES].forEach(function(sheetName) {
    var sheet = ss.getSheetByName(sheetName);
    if (!sheet) return;
    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    if (headers[9] !== 'Picked For') {
      sheet.insertColumnAfter(9);
      sheet.getRange(1, 10).setValue('Picked For').setFontWeight('bold').setBackground('#1565c0').setFontColor('#ffffff').setHorizontalAlignment('center');
    }
  });
}

// NOTE: ensureGloveSwapsPickedForColumn() was removed - Glove Swaps sheet is regenerated by generateGloveSwaps()

/**
 * Updates the Location (F) column in the Gloves tab based on Assigned To (H), referencing Employees tab (A: Name, C: Location).
 * If Assigned To matches any name in Employees tab (including non-employee states), set Location to that row's location.
 * Otherwise, leave as is.
 */
function updateGlovesLocationsFromAssignedTo() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var glovesSheet = ss.getSheetByName(SHEET_GLOVES);
  var employeesSheet = ss.getSheetByName(SHEET_EMPLOYEES);
  if (!glovesSheet || !employeesSheet) return;
  var glovesData = glovesSheet.getDataRange().getValues();
  var employeesData = employeesSheet.getDataRange().getValues();
  if (glovesData.length < 2 || employeesData.length < 2) return;
  // Build a map of all names (lowercase, trimmed) to location from Employees tab
  var nameToLocMap = {};
  for (var i = 1; i < employeesData.length; i++) {
    var name = (employeesData[i][0] || '').toString().trim().toLowerCase();
    var loc = employeesData[i][2] || '';
    if (name) nameToLocMap[name] = loc;
  }
  // For each glove row, update Location (F) if Assigned To matches any name in Employees tab
  for (var j = 1; j < glovesData.length; j++) {
    var assignedTo = (glovesData[j][7] || '').toString().trim().toLowerCase(); // H
    if (assignedTo && nameToLocMap.hasOwnProperty(assignedTo)) {
      glovesSheet.getRange(j+1, 6).setValue(nameToLocMap[assignedTo]); // F
    }
  }
}

// NOTE: updateGloveRow() was removed - logic consolidated into onEdit() function

// REMOVED: Duplicate/partial onEdit handler. All onEdit logic is consolidated into the single onEdit function below.

/**
 * Placeholder: Generate Glove Swaps report.
 * Uses Employees and Gloves data to determine upcoming swaps.
 */
function generateGloveSwaps() {
  try {
    logEvent('Generating Glove Swaps report...');
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var swapSheet = ss.getSheetByName(SHEET_GLOVE_SWAPS);
    swapSheet.clear();
    var currentRow = 1;
    var classes = [0, 2, 3];
    var classNames = {0: 'Class 0', 2: 'Class 2', 3: 'Class 3'};
    var today = new Date();
    var ignoreNames = [
      'on shelf', 'in testing', 'packed for delivery', 'packed for testing',
      'failed rubber', 'lost', 'not repairable', '', 'n/a', 'ready for test', 'ready for delivery', 'assigned', 'destroyed'
    ];
    var employeesSheet = ss.getSheetByName(SHEET_EMPLOYEES);
    var glovesSheet = ss.getSheetByName(SHEET_GLOVES);
    var employees = employeesSheet.getDataRange().getValues();
    var gloves = glovesSheet.getDataRange().getValues();
    if (employees.length < 2 || gloves.length < 2) {
      Logger.log('No data in Employees or Gloves');
      return;
    }
    var empHeaders = employees[0];
    var gloveHeaders = gloves[0];
    var empData = employees.slice(1);
    var gloveData = gloves.slice(1);
    var empMap = {};
    empData.forEach(function(row) {
      var name = (row[0] || '').toString().trim().toLowerCase();
      if (name && ignoreNames.indexOf(name) === -1) {
        empMap[name] = row;
      }
    });
    classes.forEach(function(gloveClass) {
      swapSheet.getRange(currentRow, 1, 1, 10).merge().setValue(classNames[gloveClass] + ' Glove Swaps');
      swapSheet.getRange(currentRow, 1, 1, 10)
        .setFontWeight('bold').setFontSize(12).setBackground('#e3eafc').setFontColor('#0d47a1').setHorizontalAlignment('center');
      currentRow++;
      var visibleHeaders = [
        'Employee', 'Current Glove #', 'Size', 'Date Assigned', 'Change Out Date', 'Days Left', 'Pick List', 'Status', 'Picked', 'Date Changed'
      ];
      swapSheet.getRange(currentRow, 1, 1, visibleHeaders.length).setValues([visibleHeaders]);
      swapSheet.getRange(currentRow, 1, 1, visibleHeaders.length)
        .setFontWeight('bold').setFontColor('#ffffff').setHorizontalAlignment('center').setBackground(HEADER_BG_COLOR);
      currentRow++;
      var swapRows = [];
      var daysLeftStyles = [];
      var swapMeta = [];
      gloveData.forEach(function(glove) {
        if (parseInt(glove[2], 10) !== gloveClass) return;
        var assignedTo = (glove[7] || '').toString().trim().toLowerCase();
        if (!assignedTo || ignoreNames.indexOf(assignedTo) !== -1 || !empMap[assignedTo]) {
          return;
        }
        var emp = empMap[assignedTo];
        var itemNum = glove[0];
        var size = glove[1];
        var dateAssigned = glove[4];
        var changeOutDate = glove[8];
        var status = glove[6];
        var daysLeft = '';
        var daysLeftCell = {};
        var days = null;
        if (changeOutDate && !isNaN(new Date(changeOutDate))) {
          var diff = (new Date(changeOutDate) - today) / (1000*60*60*24);
          days = Math.ceil(diff);
          if (days < 0) {
            daysLeft = 'OVERDUE';
            daysLeftCell = {bold: true, color: '#ff5252'};
          } else if (days <= 14) {
            daysLeft = days;
            daysLeftCell = {bold: true, color: '#ff9800'};
          } else {
            daysLeft = days;
            daysLeftCell = {bold: false, color: '#388e3c'};
          }
        }
        if (dateAssigned && changeOutDate && daysLeft !== '' && ((typeof daysLeft === 'number' && daysLeft < 32) || daysLeft === 'OVERDUE')) {
          swapMeta.push({
            emp: emp,
            itemNum: itemNum,
            size: size,
            dateAssigned: dateAssigned,
            changeOutDate: changeOutDate,
            daysLeft: daysLeft,
            daysLeftCell: daysLeftCell,
            status: status,
            gloveClass: gloveClass,
            empPreferredSize: emp[8],
            gloveSizeNum: parseFloat(size)
          });
        }
      });
      swapMeta.sort(function(a, b) {
        var da = new Date(a.changeOutDate);
        var db = new Date(b.changeOutDate);
        return da - db;
      });
      var assignedGloveNums = new Set();
      swapMeta.forEach(function(meta) {
        var emp = meta.emp;
        var useSize = !isNaN(parseFloat(meta.empPreferredSize)) ? parseFloat(meta.empPreferredSize) : meta.gloveSizeNum;
        var pickListValue = 'â€”';
        var found = false;
        var pickListStatus = '';
        var pickListSizeUp = false;
        var pickListStatusRaw = '';
        var pickListSize = null;
        var pickListManual = false;
        var pickListManualValue = null;
        var match = gloveData.find(function(g) {
          return g[6] && g[6].toString().trim().toLowerCase() === 'on shelf' &&
                 parseInt(g[2], 10) === meta.gloveClass &&
                 parseFloat(g[1]) === useSize &&
                 !assignedGloveNums.has(g[0]);
        });
        if (match) {
          pickListValue = match[0];
          pickListStatusRaw = 'on shelf';
          pickListSize = parseFloat(match[1]);
          assignedGloveNums.add(match[0]);
          found = true;
        }
        if (!found && !isNaN(useSize)) {
          match = gloveData.find(function(g) {
            return g[6] && g[6].toString().trim().toLowerCase() === 'on shelf' &&
                   parseInt(g[2], 10) === meta.gloveClass &&
                   parseFloat(g[1]) === useSize + 0.5 &&
                   !assignedGloveNums.has(g[0]);
          });
          if (match) {
            pickListValue = match[0];
            pickListStatusRaw = 'on shelf';
            pickListSize = parseFloat(match[1]);
            pickListSizeUp = true;
            assignedGloveNums.add(match[0]);
            found = true;
          }
        }
        if (!found) {
          match = gloveData.find(function(g) {
            var stat = g[6] && g[6].toString().trim().toLowerCase();
            return (stat === 'ready for delivery' || stat === 'in testing') &&
                   parseInt(g[2], 10) === meta.gloveClass &&
                   parseFloat(g[1]) === useSize &&
                   !assignedGloveNums.has(g[0]);
          });
          if (match) {
            pickListValue = match[0];
            pickListStatusRaw = match[6].toString().trim().toLowerCase();
            pickListSize = parseFloat(match[1]);
            assignedGloveNums.add(match[0]);
            found = true;
          }
        }
        if (!found && !isNaN(useSize)) {
          match = gloveData.find(function(g) {
            var stat = g[6] && g[6].toString().trim().toLowerCase();
            return (stat === 'ready for delivery' || stat === 'in testing') &&
                   parseInt(g[2], 10) === meta.gloveClass &&
                   parseFloat(g[1]) === useSize + 0.5 &&
                   !assignedGloveNums.has(g[0]);
          });
          if (match) {
            pickListValue = match[0];
            pickListStatusRaw = match[6].toString().trim().toLowerCase();
            pickListSize = parseFloat(match[1]);
            pickListSizeUp = true;
            assignedGloveNums.add(match[0]);
            found = true;
          }
        }
        if (pickListValue === 'â€”') {
          pickListStatus = 'Need to Purchase âŒ';
        } else if (pickListStatusRaw === 'on shelf') {
          pickListStatus = pickListSizeUp ? 'In Stock (Size Up) âš ï¸' : 'In Stock âœ…';
        } else if (pickListStatusRaw === 'ready for delivery') {
          pickListStatus = pickListSizeUp ? 'Ready For Delivery (Size Up) âš ï¸' : 'Ready For Delivery ðŸšš';
        } else if (pickListStatusRaw === 'in testing') {
          pickListStatus = pickListSizeUp ? 'In Testing (Size Up) âš ï¸' : 'In Testing â³';
        } else {
          pickListStatus = '';
        }
        swapRows.push([
          emp[0],
          meta.itemNum,
          meta.size,
          meta.dateAssigned,
          meta.changeOutDate,
          meta.daysLeft,
          pickListValue,
          pickListStatus,
          false,
          ''
        ]);
        daysLeftStyles.push(meta.daysLeftCell);
      });
      if (swapRows.length > 0) {
        swapSheet.getRange(currentRow, 1, swapRows.length, 10).setValues(swapRows);
        swapSheet.getRange(currentRow, 1, swapRows.length, 10).setHorizontalAlignment('center');
        swapSheet.getRange(currentRow, 9, swapRows.length, 1).insertCheckboxes();
        var daysLeftRange = swapSheet.getRange(currentRow, 6, swapRows.length, 1);
        for (var i = 0; i < swapRows.length; i++) {
          var val = swapRows[i][5];
          var style = daysLeftStyles[i];
          if (val === 'OVERDUE') {
            daysLeftRange.getCell(i+1,1).setFontWeight('bold').setFontColor(style.color);
          } else if (typeof val === 'number' || (val && !isNaN(val))) {
            if (style.bold) {
              daysLeftRange.getCell(i+1,1).setFontWeight('bold').setFontColor(style.color);
            } else {
              daysLeftRange.getCell(i+1,1).setFontWeight('normal').setFontColor(style.color);
            }
          } else {
            daysLeftRange.getCell(i+1,1).setFontWeight('normal').setFontColor('#388e3c');
          }
        }
        var pickListRange = swapSheet.getRange(currentRow, 7, swapRows.length, 1);
        var pickListValues = pickListRange.getValues();
        var statusRange = swapSheet.getRange(currentRow, 8, swapRows.length, 1);
        for (var i = 0; i < swapRows.length; i++) {
          var autoVal = swapRows[i][6];
          var userVal = pickListValues[i][0];
          var statusVal = swapRows[i][7];
          if (userVal !== autoVal && userVal !== '' && userVal !== 'â€”') {
            pickListRange.getCell(i+1,1).setBackground('#e3f2fd');
            var overrideGlove = gloveData.find(function(g) { return g[0] == userVal; });
            var overrideStatus = 'Need to Purchase âŒ';
            if (overrideGlove) {
              var overrideStatusRaw = overrideGlove[6] ? overrideGlove[6].toString().trim().toLowerCase() : '';
              var overrideSize = parseFloat(overrideGlove[1]);
              var empPrefSize = !isNaN(parseFloat(swapMeta[i].empPreferredSize)) ? parseFloat(swapMeta[i].empPreferredSize) : parseFloat(swapMeta[i].gloveSizeNum);
              var isSizeUp = (overrideSize === empPrefSize + 0.5);
              if (overrideStatusRaw === 'on shelf') {
                overrideStatus = isSizeUp ? 'In Stock (Size Up) âš ï¸' : 'In Stock âœ…';
              } else if (overrideStatusRaw === 'ready for delivery') {
                overrideStatus = isSizeUp ? 'Ready For Delivery (Size Up) âš ï¸' : 'Ready For Delivery ðŸšš';
              } else if (overrideStatusRaw === 'in testing') {
                overrideStatus = isSizeUp ? 'In Testing (Size Up) âš ï¸' : 'In Testing â³';
              }
            }
            statusRange.getCell(i+1,1).setValue(overrideStatus);
          } else {
            pickListRange.getCell(i+1,1).setValue(autoVal).setBackground('#ffffff');
            statusRange.getCell(i+1,1).setValue(statusVal);
          }
        }
        currentRow += swapRows.length;
      } else {
        Logger.log('No swap rows to write for class ' + gloveClass);
      }
      currentRow += 2;
    });
    updateGlovesLocationsFromAssignedTo();
  } catch (e) {
    logEvent('Error in generateGloveSwaps: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Placeholder: Generate Sleeve Swaps report.
 * Uses Employees and Sleeves data to determine upcoming swaps.
 */
function generateSleeveSwaps() {
  try {
    logEvent('Generating Sleeve Swaps report...');
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var swapSheet = ss.getSheetByName(SHEET_SLEEVE_SWAPS);
    swapSheet.clear();
    writeSwapTableHeadersDynamic(swapSheet, 1, 'Sleeves', '#ffffff', 3);
    // TODO: Add logic to populate swap data
  } catch (e) {
    logEvent('Error in generateSleeveSwaps: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Placeholder: Update Purchase Needs report.
 * Aggregates Gloves and Sleeves data to identify shortages.
 */
function updatePurchaseNeeds() {
  try {
    logEvent('Updating Purchase Needs report...');
    // TODO: Implement logic
  } catch (e) {
    logEvent('Error in updatePurchaseNeeds: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Placeholder: Update Inventory Reports.
 * Summarizes inventory status from Gloves and Sleeves.
 */
function updateInventoryReports() {
  try {
    logEvent('Updating Inventory Reports...');
    // TODO: Implement logic
  } catch (e) {
    logEvent('Error in updateInventoryReports: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Placeholder: Run Reclaims check.
 * Cross-checks assignments for compliance with location rules.
 */
function runReclaimsCheck() {
  try {
    logEvent('Running Reclaims check...');
    // TODO: Implement logic
  } catch (e) {
    logEvent('Error in runReclaimsCheck: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Placeholder: View History log.
 * Displays or exports the audit trail of all changes.
 */
function viewHistory() {
  try {
    logEvent('Viewing History log...');
    // TODO: Implement logic
  } catch (e) {
    logEvent('Error in viewHistory: ' + e, 'ERROR');
    throw e;
  }
}

/**
 * Calls all report-generation/update functions to refresh all reports/tabs.
 */
function generateAllReports() {
  try {
    logEvent('Generating all reports...');
    generateGloveSwaps();
    generateSleeveSwaps();
    updatePurchaseNeeds();
    updateInventoryReports();
    runReclaimsCheck();
    viewHistory();
    logEvent('All reports generated.');
  } catch (e) {
    logEvent('Error in generateAllReports: ' + e, 'ERROR');
    throw e;
  }
}

// NOTE: The consolidated onEdit function below handles both Gloves and Glove Swaps tabs.
// All onEdit logic has been merged into a single function.

// NOTE: updateGloveLocationAndStatus() was removed - logic consolidated into onEdit() function

// REMOVED: Duplicate onEdit handler for Gloves tab. All onEdit logic is consolidated into the single onEdit function below.

/**
 * Main edit processor for Gloves and Glove Swaps tabs.
 * Called by onEditHandler (installable trigger).
 * Updates Status, Location, and Change Out Date on Gloves tab when Assigned To, Date Assigned, or Location changes.
 * Handles Picked checkbox and Date Changed logic for Glove Swaps tab.
 *
 * NOTE: This function is named processEdit (not onEdit) to prevent Google's simple trigger
 * from auto-running it alongside our installable trigger, which causes conflicts.
 */
function processEdit(e) {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = e.range.getSheet();
  var sheetName = sheet.getName();
  var row = e.range.getRow();
  var col = e.range.getColumn();

  // Debug logging
  Logger.log('onEdit triggered - Sheet: ' + sheetName + ', Row: ' + row + ', Col: ' + col);

  if (row < 2) return; // Skip header

  // ========== GLOVES TAB ==========
  if (sheetName === 'Gloves') {
    Logger.log('Processing Gloves tab edit');
    var employeesSheet = ss.getSheetByName('Employees');
    if (!employeesSheet) {
      Logger.log('ERROR: Employees sheet not found');
      return;
    }

    var assignedTo = sheet.getRange(row, 8).getValue(); // H
    var dateAssigned = sheet.getRange(row, 5).getValue(); // E
    var testDate = sheet.getRange(row, 4).getValue(); // D
    var statusCell = sheet.getRange(row, 7); // G
    var locationCell = sheet.getRange(row, 6); // F
    var changeOutDateCell = sheet.getRange(row, 9); // I

    Logger.log('Assigned To: ' + assignedTo + ', Test Date: ' + testDate + ', Date Assigned: ' + dateAssigned);

    // Helper: Find location for a given name/status
    function findLocation(name) {
      var empData = employeesSheet.getDataRange().getValues();
      for (var i = 1; i < empData.length; i++) {
        if (empData[i][0] && empData[i][0].toString().trim().toLowerCase() === name.toString().trim().toLowerCase()) {
          return empData[i][2]; // Location (col C)
        }
      }
      return '';
    }

    // Update Status (G) based on Assigned To (H)
    var status = '';
    if (assignedTo) {
      var lower = assignedTo.toString().toLowerCase();
      if (lower === 'on shelf') status = 'On Shelf';
      else if (lower === 'packed for delivery') status = 'Ready For Delivery';
      else if (lower === 'packed for testing') status = 'Ready For Test';
      else if (lower === 'in testing') status = 'In Testing';
      else if (lower === 'failed rubber') status = 'Failed Rubber';
      else if (lower === 'lost') status = 'Lost';
      else status = 'Assigned';

      Logger.log('Setting Status to: ' + status);
      statusCell.setValue(status);
    }

    // Update Location (F) based on Assigned To (H)
    var location = findLocation(assignedTo);
    Logger.log('Found Location: ' + location);
    if (location) {
      locationCell.setValue(location);
    }

    // Update Change Out Date (I) based on rules
    var changeOutDate = '';
    if (assignedTo && status) {
      if (status === 'Assigned') {
        if (dateAssigned) {
          // 3 months for most, 6 months for Northern Lights
          var months = 3;
          if (location && location.toString().toLowerCase().indexOf('northern lights') !== -1) months = 6;
          var d = parseDateFlexible(dateAssigned);
          if (d) {
            d.setMonth(d.getMonth() + months);
            changeOutDate = Utilities.formatDate(d, ss.getSpreadsheetTimeZone(), 'MM/dd/yyyy');
          }
        }
      } else if (status === 'On Shelf' && testDate) {
        // 1 year past Test Date
        Logger.log('Calculating Change Out Date for On Shelf - Test Date: ' + testDate);
        var d2 = parseDateFlexible(testDate);
        Logger.log('Parsed Test Date: ' + d2);
        if (d2) {
          d2.setFullYear(d2.getFullYear() + 1);
          changeOutDate = Utilities.formatDate(d2, ss.getSpreadsheetTimeZone(), 'MM/dd/yyyy');
          Logger.log('Calculated Change Out Date: ' + changeOutDate);
        }
      }
    }
    if (changeOutDate) {
      Logger.log('Setting Change Out Date to: ' + changeOutDate);
      changeOutDateCell.setValue(changeOutDate);
    }
    return;
  }

  // ========== GLOVE SWAPS TAB ==========
  if (sheetName === SHEET_GLOVE_SWAPS) {
    var headersRow = 0;
    for (var r = row; r > 0; r--) {
      if ((sheet.getRange(r, 1).getValue() + '').toLowerCase() === 'employee') {
        headersRow = r;
        break;
      }
    }
    if (!headersRow || row <= headersRow) return;
    var pickedCol = 9; // I
    var dateChangedCol = 10; // J
    var pickListCol = 7; // G
    var statusCol = 8; // H
    var daysLeftCol = 6; // F
    var picked = sheet.getRange(row, pickedCol).getValue();
    var pickList = sheet.getRange(row, pickListCol).getValue();
    var emp = sheet.getRange(row, 1).getValue();
    var itemNum = sheet.getRange(row, 2).getValue();
    var size = sheet.getRange(row, 3).getValue();
    var dateAssigned = sheet.getRange(row, 4).getValue();
    var changeOutDate = sheet.getRange(row, 5).getValue();
    var status = sheet.getRange(row, statusCol).getValue();
    var daysLeft = sheet.getRange(row, daysLeftCol).getValue();
    var dateChanged = sheet.getRange(row, dateChangedCol).getValue();
    var glovesSheet = ss.getSheetByName(SHEET_GLOVES);
    var glovesData = glovesSheet.getDataRange().getValues();
    var glovesHeaders = glovesData[0];
    var pickedForColGloves = 10; // J (Gloves tab)
    if (col === dateChangedCol) {
      if (!picked && dateChanged) {
        sheet.getRange(row, dateChangedCol).setValue('');
        SpreadsheetApp.getUi().alert('You must check the Picked box before entering a Date Changed value.');
        return;
      }
    }
    function findGloveRow(itemNum) {
      for (var i = 1; i < glovesData.length; i++) {
        if (glovesData[i][0] == itemNum) return i + 1;
      }
      return null;
    }
    // Picked checkbox checked
    if (col === pickedCol && picked === true && pickList && pickList !== 'â€”') {
      var now = new Date();
      var dateStr = Utilities.formatDate(now, ss.getSpreadsheetTimeZone(), 'yyyy-MM-dd');
      var statusAfter = 'Ready For Delivery ðŸšš';
      var assignedToAfter = 'Packed For Delivery';
      sheet.getRange(row, statusCol).setValue(statusAfter);
      var gloveRow = findGloveRow(pickList);
      if (gloveRow) {
        glovesSheet.getRange(gloveRow, 7).setValue('Ready For Delivery');
        glovesSheet.getRange(gloveRow, 8).setValue(assignedToAfter);
        glovesSheet.getRange(gloveRow, 5).setValue(dateStr);
        glovesSheet.getRange(gloveRow, 9).setValue(changeOutDate);
        glovesSheet.getRange(gloveRow, pickedForColGloves).setValue(emp + ' Picked On ' + dateStr);
      }
    }
    // Picked checkbox unchecked
    else if (col === pickedCol && picked === false) {
      var gloveRow = findGloveRow(pickList);
      if (gloveRow) {
        glovesSheet.getRange(gloveRow, 7).setValue('On Shelf');
        glovesSheet.getRange(gloveRow, 8).setValue('On Shelf');
        glovesSheet.getRange(gloveRow, 5).setValue('');
        glovesSheet.getRange(gloveRow, pickedForColGloves).setValue('');
      }
      sheet.getRange(row, statusCol).setValue('In Stock âœ…').setFontWeight('normal').setFontColor('black');
    }
    // Date Changed entered
    else if (col === dateChangedCol && pickList && pickList !== 'â€”') {
      var gloveRow = findGloveRow(pickList);
      if (dateChanged && gloveRow) {
        glovesSheet.getRange(gloveRow, 7).setValue('Assigned');
        glovesSheet.getRange(gloveRow, 8).setValue(emp);
        glovesSheet.getRange(gloveRow, 5).setValue(dateChanged);
        glovesSheet.getRange(gloveRow, pickedForColGloves).setValue('');
        sheet.getRange(row, statusCol).setValue('Assigned').setFontWeight('bold').setFontColor('#388e3c');
        var daysLeftCell = sheet.getRange(row, daysLeftCol);
        if (daysLeftCell.getValue() === 'OVERDUE') {
          daysLeftCell.setValue('Assigned').setFontWeight('bold').setFontColor('#388e3c');
        }
      }
      // Date Changed was removed
      else if (!dateChanged && gloveRow) {
        glovesSheet.getRange(gloveRow, 7).setValue('Ready For Delivery');
        glovesSheet.getRange(gloveRow, 8).setValue('Packed For Delivery');
        glovesSheet.getRange(gloveRow, 5).setValue('');
        glovesSheet.getRange(gloveRow, pickedForColGloves).setValue(emp + ' Picked On ' + Utilities.formatDate(new Date(), ss.getSpreadsheetTimeZone(), 'yyyy-MM-dd'));
        sheet.getRange(row, statusCol).setValue('Ready For Delivery ðŸšš').setFontWeight('normal').setFontColor('black');
        var origChangeOutDate = sheet.getRange(row, 5).getValue();
        if (origChangeOutDate && !isNaN(new Date(origChangeOutDate))) {
          var diff = (new Date(origChangeOutDate) - new Date()) / (1000*60*60*24);
          var days = Math.ceil(diff);
          var daysLeftVal = '';
          var daysLeftStyle = {};
          if (days < 0) {
            daysLeftVal = 'OVERDUE';
            daysLeftStyle = {bold: true, color: '#ff5252'};
          } else if (days <= 14) {
            daysLeftVal = days;
            daysLeftStyle = {bold: true, color: '#ff9800'};
          } else {
            daysLeftVal = days;
            daysLeftStyle = {bold: false, color: '#388e3c'};
          }
          var daysLeftCell = sheet.getRange(row, daysLeftCol);
          daysLeftCell.setValue(daysLeftVal);
          if (daysLeftVal === 'OVERDUE') {
            daysLeftCell.setFontWeight('bold').setFontColor(daysLeftStyle.color);
          } else if (typeof daysLeftVal === 'number' || (daysLeftVal && !isNaN(daysLeftVal))) {
            if (daysLeftStyle.bold) {
              daysLeftCell.setFontWeight('bold').setFontColor(daysLeftStyle.color);
            } else {
              daysLeftCell.setFontWeight('normal').setFontColor(daysLeftStyle.color);
            }
          } else {
            daysLeftCell.setFontWeight('normal').setFontColor('#388e3c');
          }
        }
      }
    }
    // NOTE: Removed call to updateGlovesLocationsFromAssignedTo() - individual row updates handled above
    return;
  }
}

/**
 * Utility: Robustly parse a date string in MM/DD/YYYY or YYYY-MM-DD format.
 * Returns a Date object or null if invalid.
 */
function parseDateFlexible(dateStr) {
  if (!dateStr) return null;
  if (dateStr instanceof Date && !isNaN(dateStr)) return dateStr;
  if (typeof dateStr !== 'string') dateStr = String(dateStr);
  // Try native Date parsing first
  var d = new Date(dateStr);
  if (!isNaN(d)) return d;
  // Try MM/DD/YYYY
  var mdy = dateStr.match(new RegExp('^(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})$'));
  if (mdy) {
    var m = parseInt(mdy[1], 10) - 1;
    var d2 = parseInt(mdy[2], 10);
    var y = parseInt(mdy[3], 10);
    var dt = new Date(y, m, d2);
    if (!isNaN(dt)) return dt;
  }
  // Try YYYY-MM-DD
  var ymd = dateStr.match(new RegExp('^(\\d{4})[\\/\\-](\\d{1,2})[\\/\\-](\\d{1,2})$'));
  if (ymd) {
    var y2 = parseInt(ymd[1], 10);
    var m2 = parseInt(ymd[2], 10) - 1;
    var d3 = parseInt(ymd[3], 10);
    var dt2 = new Date(y2, m2, d3);
    if (!isNaN(dt2)) return dt2;
  }
  return null;
}
